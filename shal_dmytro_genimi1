import unittest
import random

def linear_search(list_of_values, value):
  """
  Функція реалізує алгоритм лінійного пошуку.

  Args:
    list_of_values: Список значень, в якому буде шукатися value.
    value: Значення, яке шукається.

  Returns:
    Індекс value в list_of_values, якщо value знайдено, інакше -1.
  """
  for i, item in enumerate(list_of_values):
    if item == value:
      return i
  return -1

def merge_sort(lst):
  """
  Функція реалізує алгоритм сортування злиттям.

  Args:
    lst: Несортований список.

  Returns:
    Відсортований список lst.
  """
  if len(lst) <= 1:
    return lst
  mid = len(lst) // 2
  left_half = merge_sort(lst[:mid])
  right_half = merge_sort(lst[mid:])
  return merge(left_half, right_half)

def merge(left_half, right_half):
  """
  Функція злиття двох відсортованих списків.

  Args:
    left_half: Перший відсортований список.
    right_half: Другий відсортований список.

  Returns:
    Злитий відсортований список.
  """
  result = []
  i = 0
  j = 0
  while i < len(left_half) and j < len(right_half):
    if left_half[i] < right_half[j]:
      result.append(left_half[i])
      i += 1
    else:
      result.append(right_half[j])
      j += 1
  result += left_half[i:]
  result += right_half[j:]
  return result

def binary_search(list_of_values, value):
  """
  Функція реалізує алгоритм бінарного пошуку.

  Args:
    list_of_values: Відсортований список значень.
    value: Значення, яке шукається.

  Returns:
    Індекс value в list_of_values, якщо value знайдено, інакше -1.
  """
  low = 0
  high = len(list_of_values) - 1
  while low <= high:
    mid = (low + high) // 2
    if list_of_values[mid] > value:
      high = mid - 1
    elif list_of_values[mid] < value:
      low = mid + 1
    else:
      return mid
  return -1

def selection_sort(lst):
  """
  Функція реалізує алгоритм сортування вибором.

  Args:
    lst: Несортований список.

  Returns:
    Відсортований список lst.
  """
  for i in range(len(lst)):
    min_index = i
    for j in range(i + 1, len(lst)):
      if lst[j] < lst[min_index]:
        min_index = j
    lst[i], lst[min_index] = lst[min_index], lst[i]
  return lst

def quick_sort(lst):
  """
  Sorts a list using quicksort algorithm with three-way partitioning for duplicates.

  Args:
    lst: The list to be sorted.

  Returns:
    The sorted list.
  """
  if len(lst) <= 1:
    return lst
  pivot_index = random.randint(0, len(lst) - 1)
  pivot = lst[pivot_index]
  left = []
  equal = []
  right = []
  for item in lst:
    if item < pivot:
      left.append(item)
    elif item > pivot:
      right.append(item)
    else:
      equal.append(item)
  return quick_sort(left) + equal + quick_sort(right)



class TestAlgorithms(unittest.TestCase):

  def test_linear_search_found(self):
    list_of_values = [1, 4, 2, 8, 5]
    value = 4
    expected_index = 1
    actual_index = linear_search(list_of_values, value)
    self.assertEqual(expected_index, actual_index)

  def test_linear_search_not_found(self):
    list_of_values = [1, 4, 2, 8, 5]
    value = 9
    expected_index = -1
    actual_index = linear_search(list_of_values, value)
    self.assertEqual(expected_index, actual_index)

  def test_merge_sort(self):
    unsorted_list = [5, 2, 4, 6, 1, 3]
    expected_sorted_list = [1, 2, 3, 4, 5, 6]
    sorted_list = merge_sort(unsorted_list)
    self.assertEqual(expected_sorted_list, sorted_list)

  def test_binary_search_found(self):
    sorted_list = [1, 3, 5, 7, 9]
    value = 5
    expected_index = 2
    actual_index = binary_search(sorted_list, value)
    self.assertEqual(expected_index, actual_index)

  def test_binary_search_not_found(self):
    sorted_list = [1, 3, 5, 7, 9]
    value = 2
    expected_index = -1
    actual_index = binary_search(sorted_list, value)
    self.assertEqual(expected_index, actual_index)

  def test_selection_sort(self):
    unsorted_list = [5, 2, 4, 6, 1, 3]
    expected_sorted_list = [1, 2, 3, 4, 5, 6]
    sorted_list = selection_sort(unsorted_list)
    self.assertEqual(expected_sorted_list, sorted_list)

  def test_quick_sort(self):
    unsorted_list = [5, 2, 4, 6, 1, 3]
    expected_sorted_list = [1, 2, 3, 4, 5, 6]
    sorted_list = quick_sort(unsorted_list)
    self.assertEqual(expected_sorted_list, sorted_list)

if __name__ == '__main__':
  unittest.main()
